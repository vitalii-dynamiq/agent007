package cloud

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// AzureProvider handles Azure credential operations.
//
// Authentication Flow:
//  1. User configures service principal (TenantID, ClientID, ClientSecret)
//  2. Backend stores credentials encrypted
//  3. Sandbox requests credentials via credential helper
//  4. Backend exchanges service principal for Azure AD access token
//  5. Token returned to sandbox (short-lived, ~1 hour)
//
// Security:
//   - Client secrets never enter sandbox
//   - Sandbox receives only short-lived access tokens
//   - Tokens scoped to configured subscription
//
// Documentation: https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-client-creds-grant-flow
type AzureProvider struct {
	httpClient *http.Client
}

// NewAzureProvider creates a new Azure credential provider.
func NewAzureProvider() *AzureProvider {
	return &AzureProvider{
		httpClient: &http.Client{Timeout: 30 * time.Second},
	}
}

// GetAccessToken exchanges service principal credentials for an Azure AD access token.
//
// Parameters:
//   - ctx: Context for cancellation
//   - config: User's Azure credential configuration
//   - sandboxID: For logging/audit purposes
//
// Returns:
//   - Access token valid for ~1 hour
//   - Error if authentication fails
func (p *AzureProvider) GetAccessToken(ctx context.Context, config *AzureCredentialConfig, sandboxID string) (*AzureAccessToken, error) {
	if config == nil {
		return nil, fmt.Errorf("azure config is nil")
	}
	if config.TenantID == "" || config.ClientID == "" {
		return nil, fmt.Errorf("tenantId and clientId are required")
	}
	if config.ClientSecret == "" && config.CertificatePEM == "" {
		return nil, fmt.Errorf("clientSecret or certificatePem is required")
	}

	// Use client secret flow (most common)
	if config.ClientSecret != "" {
		return p.getTokenWithClientSecret(ctx, config)
	}

	// TODO: Implement certificate-based auth
	return nil, fmt.Errorf("certificate-based auth not yet implemented")
}

// getTokenWithClientSecret authenticates using client credentials grant flow.
// Documentation: https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-client-creds-grant-flow
func (p *AzureProvider) getTokenWithClientSecret(ctx context.Context, config *AzureCredentialConfig) (*AzureAccessToken, error) {
	// Azure AD token endpoint
	tokenURL := fmt.Sprintf("https://login.microsoftonline.com/%s/oauth2/v2.0/token", config.TenantID)

	// Request body
	data := url.Values{}
	data.Set("grant_type", "client_credentials")
	data.Set("client_id", config.ClientID)
	data.Set("client_secret", config.ClientSecret)
	// Default scope for Azure Management API
	data.Set("scope", "https://management.azure.com/.default")

	req, err := http.NewRequestWithContext(ctx, "POST", tokenURL, strings.NewReader(data.Encode()))
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	resp, err := p.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("token request: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("azure auth failed (status %d): %s", resp.StatusCode, string(body))
	}

	var tokenResp struct {
		AccessToken string `json:"access_token"`
		TokenType   string `json:"token_type"`
		ExpiresIn   int    `json:"expires_in"`
	}
	if err := json.Unmarshal(body, &tokenResp); err != nil {
		return nil, fmt.Errorf("parse token response: %w", err)
	}

	return &AzureAccessToken{
		AccessToken: tokenResp.AccessToken,
		TokenType:   tokenResp.TokenType,
		ExpiresIn:   tokenResp.ExpiresIn,
		ExpiresAt:   time.Now().Add(time.Duration(tokenResp.ExpiresIn) * time.Second),
	}, nil
}

// GenerateAzureCredentialHelper generates a bash script that the sandbox uses
// to authenticate with Azure CLI.
//
// The helper calls our backend to get a fresh access token, then uses
// `az login` with the token. This ensures credentials are always fresh.
//
// Sandbox Environment Variables needed:
//   - BACKEND_URL: URL of our backend
//   - SESSION_TOKEN: Short-lived JWT for authentication
//   - SANDBOX_ID: Current sandbox identifier
func GenerateAzureCredentialHelper(backendURL, sessionToken, sandboxID, subscriptionID string) string {
	return fmt.Sprintf(`#!/bin/bash
# Azure Credential Helper - Generated by Dynamiq
# This script fetches short-lived Azure credentials from the backend
# Documentation: https://learn.microsoft.com/en-us/cli/azure/authenticate-azure-cli-service-principal

set -e

# Fetch Azure access token from backend
response=$(curl -s -X POST "%s/api/cloud/azure/credentials" \
  -H "Authorization: Bearer %s" \
  -H "Content-Type: application/json" \
  -d '{"sandboxId": "%s", "provider": "azure"}')

# Check for errors
error=$(echo "$response" | jq -r '.error // empty')
if [ -n "$error" ]; then
  echo "Error: $error" >&2
  exit 1
fi

# Extract token
access_token=$(echo "$response" | jq -r '.azure.access_token')
expires_at=$(echo "$response" | jq -r '.azure.expires_at')

if [ -z "$access_token" ] || [ "$access_token" = "null" ]; then
  echo "Error: Failed to get access token" >&2
  exit 1
fi

# Set the token as environment variable for Azure CLI
export AZURE_ACCESS_TOKEN="$access_token"

# Configure Azure CLI to use the token
# Note: Azure CLI doesn't have credential_process equivalent, so we:
# 1. Set subscription if provided
# 2. Use az account get-access-token to inject the token

%s

echo "Azure credentials configured (expires: $expires_at)"
`, backendURL, sessionToken, sandboxID, func() string {
		if subscriptionID != "" {
			return fmt.Sprintf("az account set --subscription %s 2>/dev/null || true", subscriptionID)
		}
		return ""
	}())
}

// GenerateAzureEnvVars returns environment variables for Azure CLI authentication.
// This is an alternative to the credential helper when environment variable
// authentication is sufficient.
func GenerateAzureEnvVars(token *AzureAccessToken, config *AzureCredentialConfig) map[string]string {
	vars := map[string]string{
		"AZURE_ACCESS_TOKEN": token.AccessToken,
	}

	if config != nil {
		if config.SubscriptionID != "" {
			vars["AZURE_SUBSCRIPTION_ID"] = config.SubscriptionID
		}
		if config.TenantID != "" {
			vars["AZURE_TENANT_ID"] = config.TenantID
		}
		if config.ClientID != "" {
			vars["AZURE_CLIENT_ID"] = config.ClientID
		}
	}

	return vars
}

// ValidateAzureCredentials tests if the Azure credentials are valid.
func (p *AzureProvider) ValidateCredentials(ctx context.Context, config *AzureCredentialConfig) error {
	token, err := p.GetAccessToken(ctx, config, "validation")
	if err != nil {
		return fmt.Errorf("credential validation failed: %w", err)
	}

	// Optionally test the token by making a simple API call
	req, err := http.NewRequestWithContext(ctx, "GET",
		"https://management.azure.com/subscriptions?api-version=2022-12-01", nil)
	if err != nil {
		return fmt.Errorf("create test request: %w", err)
	}
	req.Header.Set("Authorization", "Bearer "+token.AccessToken)

	resp, err := p.httpClient.Do(req)
	if err != nil {
		return fmt.Errorf("test request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusUnauthorized || resp.StatusCode == http.StatusForbidden {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("credentials invalid: %s", string(body))
	}

	return nil
}

// GetSubscriptions lists available Azure subscriptions for the service principal.
func (p *AzureProvider) GetSubscriptions(ctx context.Context, config *AzureCredentialConfig) ([]map[string]interface{}, error) {
	token, err := p.GetAccessToken(ctx, config, "list-subscriptions")
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET",
		"https://management.azure.com/subscriptions?api-version=2022-12-01", nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Authorization", "Bearer "+token.AccessToken)

	resp, err := p.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request: %w", err)
	}
	defer resp.Body.Close()

	var result struct {
		Value []map[string]interface{} `json:"value"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}

	return result.Value, nil
}

// writeJSON is a helper to write JSON to a buffer
func writeJSON(buf *bytes.Buffer, v interface{}) error {
	return json.NewEncoder(buf).Encode(v)
}
